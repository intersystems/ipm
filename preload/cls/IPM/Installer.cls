Class IPM.Installer Extends %Projection.AbstractProjection
{

Projection Reference As Installer;

/// Version used for autoinstall release
Parameter VERSION;

/// Number of files for autoinstall release
Parameter FILESCOUNT = 0;

/// Application Definition
XData PM [ XMLNamespace = INSTALLER ]
{
<Manifest>
<Default Name="MODDIR" Dir="${MGRDIR}" />
<Default Name="SRCDIR" Dir="${MODDIR}src" />
<Default Name="REGISTRY" Value="https://pm.community.intersystems.com" />
<Default Name="TRACKINGID" Value="UA-126752118-1" />

<Namespace Name="${CURNS}" Code="${CURNSRoutineDB}" Data="${CURNSGlobalDB}" Create="no" Ensemble="0">
  <Configuration>
      <ClassMapping Package="%IPM" From="${CURNSRoutineDB}" />
      <RoutineMapping Routines="%IPM.*" Type="ALL" From="${CURNSRoutineDB}" /> 
  </Configuration>

  <Import File="${SRCDIR}" Recurse="1"/>

  <Invoke Class="%IPM.Main" Method="UpdateLanguageExtensions" CheckStatus="true" />
  <Invoke Class="IPM.Installer" Method="ZPMInit" CheckStatus="true">
    <Arg Value="${REGISTRY}"/> 
    <Arg Value="${TRACKINGID}"/>
  </Invoke>
  <Invoke Class="IPM.Installer" Method="ZPMLoad" CheckStatus="true">
    <Arg Value="${MODDIR}"/>
  </Invoke>
  <Invoke Class="IPM.Installer" Method="ZPMCompile" CheckStatus="true" />
</Namespace>

</Manifest>
}

XData MapOnly [ XMLNamespace = INSTALLER ]
{
<Manifest>
  <Namespace Name="${CURNS}" Code="${CURNSRoutineDB}" Data="${CURNSGlobalDB}" Create="no" Ensemble="0">
    <Configuration>
        <ClassMapping Package="%IPM" From="${CURNSRoutineDB}" />
        <RoutineMapping Routines="%IPM.*" Type="ALL" From="${CURNSRoutineDB}" /> 
    </Configuration>
  </Namespace>
</Manifest>
}

/// This is a method generator whose code is generated by XGL.
ClassMethod setup(ByRef pVars, pLogLevel As %Integer, pInstaller As %Installer.Installer, pLogger As %Installer.AbstractLogger) As %Status [ CodeMode = objectgenerator, Internal ]
{
  #; Let our XGL document generate code for this method. 
  Do %code.WriteLine(" If $Data(pVars, path)#10,path'="""" Set pVars(""MODDIR"")=path")
  Do %code.WriteLine(" Set pVars(""CURNS"")=$namespace")
  Do %code.WriteLine(" Set prevNS = $namespace")
  Do %code.WriteLine(" New $Namespace")
  Do %code.WriteLine(" Set $Namespace = ""%SYS"" ")
  Do %code.WriteLine(" Kill properties")
  Do %code.WriteLine(" Set sc = ##class(Config.Namespaces).Get(prevNS, .properties)")
  Do %code.WriteLine(" Set pVars(""CURNSRoutineDB"")=$Get(properties(""Routines""))")
  Do %code.WriteLine(" Set pVars(""CURNSGlobalDB"")=$Get(properties(""Globals""))")
  Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "PM")
}

ClassMethod Map(ByRef pVars, pLogLevel As %Integer, pInstaller As %Installer.Installer, pLogger As %Installer.AbstractLogger) As %Status [ CodeMode = objectgenerator, Internal ]
{
  #; Let our XGL document generate code for this method.
  Do %code.WriteLine(" Set pVars(""CURNS"")=$namespace")
  Do %code.WriteLine(" Set prevNS = $namespace")
  Do %code.WriteLine(" New $Namespace")
  Do %code.WriteLine(" Set $Namespace = ""%SYS"" ")
  Do %code.WriteLine(" Kill properties")
  Do %code.WriteLine(" Set sc = ##class(Config.Namespaces).Get(prevNS, .properties)")
  Do %code.WriteLine(" Set pVars(""CURNSRoutineDB"")=$Get(properties(""Routines""))")
  Do %code.WriteLine(" Set pVars(""CURNSGlobalDB"")=$Get(properties(""Globals""))")
  Do %code.WriteLine(" If ##class(Config.MapPackages).Exists(prevNS,""%IPM"") { Quit $$$OK }")
  Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "MapOnly")
}

ClassMethod AsyncSetup(Args...)
{
  Try {
    Set tSC = ..setup(Args...)
  } Catch ex {
    Set tSC = ex.AsStatus()
  }  
  Do $System.Event.Signal($ZParent, tSC)
}

ClassMethod ZPMInit(pRegistry As %String = "", pAnalyticsTrackingID As %String = "")
{
    //If (pRegistry'="") {
    //  $$$QuitOnError(##class(%IPM.Main).Shell("repo -t registry -name registry -url "_ pRegistry))
    //}
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetDefaultRegistry(pRegistry, 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetAnalyticsAvailable(1, 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetAnalyticsTrackingId(pAnalyticsTrackingID, 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue("ColorScheme","", 0))
    Set tPipCallerKey = ##class(%IPM.Repo.UniversalSettings).#PipCaller
    Set tPipCallerValue = ..DetectPipCaller()
    If tPipCallerValue = "" {
      Write !, "WARNING: Failed to detect proper way of calling pip."
      Write "You can set it manually using `config set PipCaller $lb(""<python-path>"", ""-m"", ""pip"")`" 
    }
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue(tPipCallerKey, tPipCallerValue, 0))
    Quit $$$OK
}

/// Detect the proper call to `pip`. Possible options are `python3 -m pip`, `python -m pip`, `irispip.exe` (for Windows IRIS <= 2024.1).
/// We prefer `python3 -m pip` over `python -m pip` because on certain legacy systems, `python` might be Python 2.
ClassMethod DetectPipCaller() As %String
{
  Write !, "Detecting pip caller"
  If $$$isWINDOWS {
    set irispip = ##class(%File).NormalizeFilename("irispip.exe", $System.Util.BinaryDirectory())
    // irispip.exe is the first one we try
    Set tPipCallers = $lb($lb(irispip), $lb("python3.exe", "-m", "pip"), $lb("python.exe","-m", "pip"))
  } Else {
    Set tPipCallers = $lb($lb("python3", "-m", "pip"), $lb("python", "-m", "pip"))
  }

  Set ptr = 0
  Set flags = "/SHELL/LOGCMD/STDOUT=""DetectPipCaller.log""/STDERR=""DetectPipCaller.err"""
  While $ListNext(tPipCallers, ptr, cmd) {
    Write !, "Checking """, $LISTTOSTRING(cmd, " "), """"
    Set program = $List(cmd)
    Do ..ListToMultiDimensional($List(cmd, 2, *), .args)
    Set retCode = $ZF(-100, flags, program, .args)
    If retCode = 0 {
      Write !, "Success!"
      Return cmd
    }
  }

  Return ""
}

ClassMethod ListToMultiDimensional(pList As %List, Output pOutput)
{
  Set ptr = 0
  Kill pOutput
  While $ListNext(pList, ptr, tItem) {
    Set pOutput($Increment(pOutput)) = tItem
  }
}

ClassMethod ZPMLoad(pDirectoryName)
{
  Quit ##class(%IPM.Main).Shell("load "_pDirectoryName)
}

ClassMethod ZPMCompile()
{
  Quit ##class(%IPM.Main).Shell("ZPM compile")
}

ClassMethod EndCompile(qstruct) As %Status
{
  #; Behave as simple installer
  If (..#FILESCOUNT'>0)||(..#VERSION="") QUIT $$$OK

  #; This flag used in development
  if $DATA(^%IPM("skipinstall")) QUIT $$$OK
  
  #; Installed version newer
  if '..NeedInstall() QUIT $$$OK

  Write !,"Extracting package"
  $$$QuitOnError(..ExtractPackage(.tModDir))
  
  Write !,"Installing ZPM"

  set ts = $ZHOROLOG
  set logFile=##class(%File).TempFilename()
  JOB ..AsyncSetup(tModDir, 3):(:::logFile):0
  if '$test {
    quit $$$ERROR($$$GeneralError, "Job did not start")
  }

  #; Wait setup
  set child=$zchild
  Set tSC = $$$OK
  do { 
    hang 1
    Set $Listbuild(res, tSC) = $System.Event.WaitMsg("", 10)
    Quit:res=1
  } while $data(^$JOB(child))

  set fs=##class(%Stream.FileCharacter).%New()
  set fs.Filename=logFile
  while 'fs.AtEnd {
    write !,fs.ReadLine()
  }
  if ##class(%File).Delete(logFile)

  Write !,"Time spent ",$ZHOROLOG - ts

  QUIT tSC
}

/// Check currently installed version, if any
ClassMethod NeedInstall(Output version As %String)
{
  try {
    set module = ##class(%IPM.Storage.Module).NameOpen("zpm")
    if '$ISOBJECT(module) {
      RETURN 1
    }

    set version = ##class(%IPM.General.SemanticVersion).FromString(..#VERSION)
    if $isobject(version) {
      RETURN version.Follows(module.Version)
    }

  } CATCH ex {
    
  }
  QUIT 1
}

ClassMethod MakeFile(pPackagePath As %String, pInstaller As %String)
{
  set tPackage = ##class(%Stream.FileBinary).%New()
  set tInstaller = ##class(%Stream.FileCharacter).%New()
  if tPackage.LinkToFile(pPackagePath),tInstaller.LinkToFile(pInstaller) {
    $$$QuitOnError(..Make(tPackage, tInstaller))
    Quit tInstaller.%Save()
  }
  Quit $$$OK
}

ClassMethod Make(pPackage As %Stream.Object, ByRef pStream As %Stream.TmpCharacter) As %Status
{
  Set tSC = $$$OK
  try {
		Set tModule = ##class(%IPM.Storage.Module).NameOpen("zpm")

    Set tmpDir = ..CreateTempDir()
    $$$ThrowOnError(##class(%IPM.General.Archive).Extract(pPackage, tmpDir))

    Do ..CollectPackage(tmpDir, .tList, tmpDir)

    Do ..CompactPackage(.tList)

    Set param = ##class(%Dictionary.ParameterDefinition).%OpenId($CLASSNAME()_"||VERSION")
    Set param.Default = tModule.VersionString
    Do param.%Save()

    Set param = ##class(%Dictionary.ParameterDefinition).%OpenId($CLASSNAME()_"||FILESCOUNT")
    Set param.Default = $Get(tList)
    Do param.%Save()

    Set tSC = $SYSTEM.OBJ.ExportToStream($CLASSNAME()_".CLS", .pStream, "/diffexport/exportversion=iris2019.1")
  } Catch e {
    Set tSC = e.AsStatus()
  }
  QUIT tSC
}

ClassMethod CollectPackage(pPath As %String, Output pList, pRoot As %String)
{
  set rs = ##class(%File).FileSetFunc(pPath)
  WHILE rs.%Next() {
    If rs.Type="D" {
      do ..CollectPackage(rs.Name, .pList, pRoot)
    } ELSE {
      #; Set $LISTBUILD(url) = $SYSTEM.CSP.FilenameToUrls(rs.Name) 
      Set pList($INCREMENT(pList)) = $LISTBUILD(rs.Name, $EXTRACT(rs.Name, $LENGTH(pRoot) + 1, *))
    }
  }
}

ClassMethod CompactPackage(ByRef pList) As %Status
{
  set file = ""
  for i=1:1:$Get(pList) {
    Set $LISTBUILD(file, name) = pList(i)
    Write !,"Compact: ", file
    
    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = file

    Set gzip = ##class(%Stream.FileBinaryGzip).%New()
    Set gzip.Filename = tmpFile
    do gzip.CopyFromAndSave(stream)
    
    Set gzip = ##class(%Stream.FileBinary).%New()
    Set gzip.Filename = tmpFile

    Set xdata = ##class(%Dictionary.XDataDefinition).%New()
    Set xdata.Name = "Data"_i
    Set xdata.Description = name
    Set xdata.SequenceNumber = 100 + i
    Do xdata.parentSetObjectId($CLASSNAME())
    set chunkSize = 22800
    while 'gzip.AtEnd {
      set data = gzip.Read(chunkSize)
      set base64 = $SYSTEM.Encryption.Base64Encode(data)
      do xdata.Data.WriteLine(base64)
      set data1 = $SYSTEM.Encryption.Base64Decode(base64)
    }
    do xdata.%Save()
    set hash = $SYSTEM.Encryption.SHA1HashStream(gzip)
  
    do ##class(%File).Delete(tmpFile)
  }
  QUIT $$$OK
  
  
  Quit $$$OK
}

ClassMethod ExtractPackage(Output pFolder As %String) As %String
{
  Set pFolder = ..CreateTempDir()

  For i=1:1:..#FILESCOUNT {
    Set xdata = ##class(%Dictionary.XDataDefinition).%OpenId($CLASSNAME()_"||Data"_i)
    Set name = xdata.Description
    Set fileName = pFolder_name

    Set tParentFolder = ##class(%File).ParentDirectoryName(fileName)    
    if '##class(%File).DirectoryExists(tParentFolder) {
      Do ##class(%File).CreateDirectoryChain(tParentFolder)
    }

    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = tmpFile
    set prev = ""
    set chunkSize = 30400
    do {
      set data = prev
      if 'xdata.Data.AtEnd {
        set data = data _ xdata.Data.Read()
      }
      set data = $ZSTRIP(data, "*C")
      set prev = $EXTRACT(data, chunkSize + 1, *)
      set data = $EXTRACT(data, 1, chunkSize)
      set chunk = $SYSTEM.Encryption.Base64Decode(data)
      do stream.Write(chunk)
    } while (prev'="")||('xdata.Data.AtEnd)
    do stream.%Save()

    set gzip = ##class(%Stream.FileBinaryGzip).%New()
    set gzip.Filename = tmpFile

    set fs = ##class(%Stream.FileCharacter).%New()
    set fs.Filename = fileName
    do fs.CopyFromAndSave(gzip)

    do ##class(%File).Delete(tmpFile)
  }
  Quit $$$OK
}

ClassMethod CreateTempDir() As %String
{
  Set tDir = $$$FileTempDir

  /// In some cases, the $zu(140, 17) will return a negated error code. 
  /// For example, it can return -28, where 28 is Unix errno for "no space left on device".
  If tDir = ("-" _ -tDir) {
    Throw ##class(%Exception.General).%New("Failed to create temporary directory. Error code: " _ -tDir)
  }
  Return ##class(%File).NormalizeDirectory(tDir)
}

}
