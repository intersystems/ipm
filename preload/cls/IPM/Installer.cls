Class IPM.Installer Extends %Projection.AbstractProjection
{

Projection Reference As Installer;

/// Version used for autoinstall release
Parameter VERSION;

/// Number of files for autoinstall release
Parameter FILESCOUNT = 0;

/// Application Definition
XData PM [ XMLNamespace = INSTALLER ]
{
<Manifest>
<Default Name="MODDIR" Dir="${MGRDIR}" />
<Default Name="SRCDIR" Dir="${MODDIR}src" />
<Default Name="REGISTRY" Value="https://pm.community.intersystems.com" />
<Default Name="TRACKINGID" Value="UA-126752118-1" />

<Namespace Name="${CURNS}" Code="${CURNSRoutineDB}" Data="${CURNSGlobalDB}" Create="no" Ensemble="0">
  <Configuration>
    <ClassMapping Package="%IPM" From="${CURNSRoutineDB}" />
    <RoutineMapping Routines="%IPM.*" Type="ALL" From="${CURNSRoutineDB}" /> 
  </Configuration>
  <Import File="${SRCDIR}" Recurse="1"/>
  <Invoke Class="%IPM.Main" Method="UpdateLanguageExtensions" CheckStatus="true" />
  <Invoke Class="IPM.Installer" Method="ZPMInit" CheckStatus="true">
    <Arg Value="${REGISTRY}"/> 
    <Arg Value="${TRACKINGID}"/>
  </Invoke>
  <Invoke Class="IPM.Installer" Method="ZPMLoad" CheckStatus="true">
    <Arg Value="${MODDIR}"/>
  </Invoke>
</Namespace>

</Manifest>
}

XData MapOnly [ XMLNamespace = INSTALLER ]
{
<Manifest>
  <Namespace Name="${CURNS}" Code="${CURNSRoutineDB}" Data="${CURNSGlobalDB}" Create="no" Ensemble="0">
    <Configuration>
        <ClassMapping Package="%IPM" From="${CURNSRoutineDB}" />
        <RoutineMapping Routines="%IPM.*" Type="ALL" From="${CURNSRoutineDB}" /> 
    </Configuration>
  </Namespace>
</Manifest>
}

/// This is a method generator whose code is generated by XGL.
ClassMethod setup(ByRef pVars, pLogLevel As %Integer, pInstaller As %Installer.Installer, pLogger As %Installer.AbstractLogger) As %Status [ CodeMode = objectgenerator, Internal ]
{
  #; Let our XGL document generate code for this method. 
  Do %code.WriteLine(" If $Data(pVars, path)#10,path'="""" Set pVars(""MODDIR"")=path")
  Do %code.WriteLine(" Set pVars(""CURNS"")=$namespace")
  Do %code.WriteLine(" Set prevNS = $namespace")
  Do %code.WriteLine(" New $Namespace")
  Do %code.WriteLine(" Set $Namespace = ""%SYS"" ")
  Do %code.WriteLine(" Kill properties")
  Do %code.WriteLine(" Set sc = ##class(Config.Namespaces).Get(prevNS, .properties)")
  Do %code.WriteLine(" Set pVars(""CURNSRoutineDB"")=$Get(properties(""Routines""))")
  Do %code.WriteLine(" Set pVars(""CURNSGlobalDB"")=$Get(properties(""Globals""))")
  Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "PM")
}

ClassMethod Map(ByRef pVars, pLogLevel As %Integer, pInstaller As %Installer.Installer, pLogger As %Installer.AbstractLogger) As %Status [ CodeMode = objectgenerator, Internal ]
{
  #; Let our XGL document generate code for this method.
  Do %code.WriteLine(" Set pVars(""CURNS"")=$namespace")
  #; Special case: if we're in %SYS and have an alternative mapping set up, keep it.
  Do %code.WriteLine(" If ($Namespace = ""%SYS"") && (##class(%SYS.Namespace).GetPackageDest(""%SYS"",""%IPM"") '[ ""irislib"") { Quit $$$OK }")
  Do %code.WriteLine(" Set prevNS = $namespace")
  Do %code.WriteLine(" New $Namespace")
  Do %code.WriteLine(" Set $Namespace = ""%SYS"" ")
  Do %code.WriteLine(" Kill properties")
  Do %code.WriteLine(" Set sc = ##class(Config.Namespaces).Get(prevNS, .properties)")
  Do %code.WriteLine(" Set pVars(""CURNSRoutineDB"")=$Get(properties(""Routines""))")
  Do %code.WriteLine(" Set pVars(""CURNSGlobalDB"")=$Get(properties(""Globals""))")
  Do %code.WriteLine(" If ##class(Config.MapPackages).Exists(prevNS,""%IPM"") && ##class(Config.MapRoutines).Exists(prevNS,""%IPM.*"") { Quit $$$OK }")
  Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "MapOnly")
}

ClassMethod AsyncSetup(Args...)
{
  Try {
    Set tSC = ..setup(Args...)
  } Catch ex {
    Set tSC = ex.AsStatus()
  }  
  Do $System.Event.Signal($ZParent, tSC)
}

ClassMethod ZPMInit(pRegistry As %String = "", pAnalyticsTrackingID As %String = "")
{
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetDefaultRegistry(pRegistry, 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetAnalyticsAvailable(1, 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetAnalyticsTrackingId(pAnalyticsTrackingID, 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue("ColorScheme","", 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue("PipCaller", "", 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue("UseStandalonePip", "", 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue("SemVerPostRelease", 0, 0))
    Quit $$$OK
}

ClassMethod ZPMLoad(pDirectoryName)
{
  // Explicitly force DeveloperMode to 0 to avoid loading tests
  // Do not map here when installed from installer; that's handled via Installer XDatas if/when needed
  Quit ##class(%IPM.Main).Shell("load "_pDirectoryName_" -DDeveloperMode=0 -DNoMapping=1")
}

ClassMethod MapIfLegacy()
{
  If ##class(%IPM.Utils.Migration).HasLegacyZPMPackage() {
    Quit ##class(%IPM.Main).Shell("enable -globally -map")
  }
  Quit $$$OK
}

ClassMethod InstallORASIfMissing()
{
  if ..ValidatePythonRuntime() {
    if '..ORASInstalled() {
      // Need to run in a background process to pick up new %IPM.Storage.Module definition
      Write !,"Installing ORAS Python components..."
      Job ..InitializeAndSignal()
      Set result = $System.Event.WaitMsg("",30)
      Set $ListBuild(msg,sc) = result
      If (msg = 0) {
        Write !,"ORAS installation timed out and may not have completed successfully."
      } ElseIf $$$ISERR(sc) {
        Write !,"An error occurred installing Python dependencies: ",$System.Status.GetErrorText(sc)
      } Else {
        Write " done."
      }
    }
  } else {
    Write !!,"WARNING: Flexible Python Runtime is not configured on this instance with a valid Python version (>=3.10). Not all IPM features will be available. If you wish to use ORAS registries, configure Flexible Python Runtime and then reinstall IPM.",!
  }
  Quit $$$OK
}

ClassMethod InitializeAndSignal()
{
  set parent = $ZParent
  set sc = ##class(%IPM.Main).Shell("zpm initialize -only")
  do $System.Event.Signal($zparent,sc)
}

ClassMethod ValidatePythonRuntime() As %Boolean
{
  try {
    set version = ..PythonMajorMinorVersion()
    if (+version < 3.10) {
      Write !!,"WARNING: Python version "_version_" is not supported. IPM requires Python 3.10 or higher.",!
      return 0
    }
  } catch e {
    return 0
  }
  return 1
}

ClassMethod ORASInstalled() [ Language = python ]
{
  try:
    import oras
    return True
  except:
    return False
}

ClassMethod PythonMajorMinorVersion() [ Language = python ]
{
  import sys
  return f"{sys.version_info.major}.{sys.version_info.minor}"
}

ClassMethod EndCompile(qstruct) As %Status
{
  #; Behave as simple installer
  If (..#FILESCOUNT'>0)||(..#VERSION="") QUIT $$$OK

  #; This flag used in development
  if $DATA(^%IPM("skipinstall")) QUIT $$$OK
  
  #; Installed version newer
  if '..NeedInstall() QUIT $$$OK

  Write !,"Extracting package"
  $$$QuitOnError(..ExtractPackage(.tModDir))
  
  Write !,"Installing ZPM"

  set ts = $ZHOROLOG
  set logFile=##class(%File).TempFilename()
  JOB ..AsyncSetup(tModDir, 3):(:::logFile):0
  if '$test {
    quit $$$ERROR($$$GeneralError, "Job did not start")
  }

  #; Wait setup
  set child=$zchild
  Set tSC = $$$OK
  do { 
    hang 1
    Set $Listbuild(res, tSC) = $System.Event.WaitMsg("", 10)
    Quit:res=1
  } while $data(^$JOB(child))

  set fs=##class(%Stream.FileCharacter).%New()
  set fs.Filename=logFile
  while 'fs.AtEnd {
    write !,fs.ReadLine()
  }
  if ##class(%File).Delete(logFile)

  Write !,"Time spent ",$ZHOROLOG - ts

  QUIT tSC
}

/// Check currently installed version, if any
ClassMethod NeedInstall(Output version As %String)
{
  try {
    set module = ##class(%IPM.Storage.Module).NameOpen("zpm")
    if '$ISOBJECT(module) {
      RETURN 1
    }

    set version = ##class(%IPM.General.SemanticVersion).FromString(..#VERSION)
    if $isobject(version) {
      RETURN version.Follows(module.Version)
    }

  } CATCH ex {
    
  }
  QUIT 1
}

ClassMethod MakeFile(pPackagePath As %String, pInstaller As %String)
{
  set tPackage = ##class(%Stream.FileBinary).%New()
  set tInstaller = ##class(%Stream.FileCharacter).%New()
  if tPackage.LinkToFile(pPackagePath),tInstaller.LinkToFile(pInstaller) {
    $$$QuitOnError(..Make(tPackage, tInstaller))
    Quit tInstaller.%Save()
  }
  Quit $$$OK
}

ClassMethod Make(pPackage As %Stream.Object, ByRef pStream As %Stream.TmpCharacter) As %Status
{
  Set tSC = $$$OK
  try {
		Set tModule = ##class(%IPM.Storage.Module).NameOpen("zpm")

    Set tmpDir = ..CreateTempDir()
    $$$ThrowOnError(##class(%IPM.General.Archive).Extract(pPackage, tmpDir))

    Do ..CollectPackage(tmpDir, .tList, tmpDir)

    Do ..CompactPackage(.tList)

    Set param = ##class(%Dictionary.ParameterDefinition).%OpenId($CLASSNAME()_"||VERSION")
    Set param.Default = tModule.VersionString
    Do param.%Save()

    Set param = ##class(%Dictionary.ParameterDefinition).%OpenId($CLASSNAME()_"||FILESCOUNT")
    Set param.Default = $Get(tList)
    Do param.%Save()

    Set tSC = $SYSTEM.OBJ.ExportToStream($CLASSNAME()_".CLS", .pStream, "/diffexport/exportversion=iris2019.1")
  } Catch e {
    Set tSC = e.AsStatus()
  }
  QUIT tSC
}

ClassMethod CollectPackage(pPath As %String, Output pList, pRoot As %String)
{
  set rs = ##class(%File).FileSetFunc(pPath)
  WHILE rs.%Next() {
    If rs.Type="D" {
      do ..CollectPackage(rs.Name, .pList, pRoot)
    } ELSE {
      #; Set $LISTBUILD(url) = $SYSTEM.CSP.FilenameToUrls(rs.Name) 
      Set pList($INCREMENT(pList)) = $LISTBUILD(rs.Name, $EXTRACT(rs.Name, $LENGTH(pRoot) + 1, *))
    }
  }
}

ClassMethod CompactPackage(ByRef pList) As %Status
{
  set file = ""
  for i=1:1:$Get(pList) {
    Set $LISTBUILD(file, name) = pList(i)
    Write !,"Compact: ", file
    
    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = file

    Set gzip = ##class(%Stream.FileBinaryGzip).%New()
    Set gzip.Filename = tmpFile
    do gzip.CopyFromAndSave(stream)
    
    Set gzip = ##class(%Stream.FileBinary).%New()
    Set gzip.Filename = tmpFile

    Set xdata = ##class(%Dictionary.XDataDefinition).%New()
    Set xdata.Name = "Data"_i
    Set xdata.Description = name
    Set xdata.SequenceNumber = 100 + i
    Do xdata.parentSetObjectId($CLASSNAME())
    set chunkSize = 22800
    while 'gzip.AtEnd {
      set data = gzip.Read(chunkSize)
      set base64 = $SYSTEM.Encryption.Base64Encode(data,1)
      do xdata.Data.Write(base64)
      set data1 = $SYSTEM.Encryption.Base64Decode(base64)
    }
    do xdata.%Save()
    set hash = $SYSTEM.Encryption.SHA1HashStream(gzip)
  
    do ##class(%File).Delete(tmpFile)
  }
  QUIT $$$OK
  
  
  Quit $$$OK
}

ClassMethod ExtractPackage(Output pFolder As %String) As %String
{
  Set pFolder = ..CreateTempDir()

  For i=1:1:..#FILESCOUNT {
    Set xdata = ##class(%Dictionary.XDataDefinition).%OpenId($CLASSNAME()_"||Data"_i)
    Set name = xdata.Description
    Set fileName = pFolder_name

    Set tParentFolder = ##class(%File).ParentDirectoryName(fileName)    
    if '##class(%File).DirectoryExists(tParentFolder) {
      Do ##class(%File).CreateDirectoryChain(tParentFolder)
    }

    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = tmpFile
    set prev = ""
    set chunkSize = 30400
    do {
      set data = prev
      if 'xdata.Data.AtEnd {
        set data = data _ xdata.Data.Read()
      }
      set data = $ZSTRIP(data, "*C")
      set prev = $EXTRACT(data, chunkSize + 1, *)
      set data = $EXTRACT(data, 1, chunkSize)
      set chunk = $SYSTEM.Encryption.Base64Decode(data)
      do stream.Write(chunk)
    } while (prev'="")||('xdata.Data.AtEnd)
    do stream.%Save()

    set gzip = ##class(%Stream.FileBinaryGzip).%New()
    set gzip.Filename = tmpFile

    if $Piece(fileName,".",*) = "whl" {
      // TODO: generalize to other binary file types?
      set fs = ##class(%Stream.FileBinary).%New()
    } else {
      set fs = ##class(%Stream.FileCharacter).%New()
    }
    set fs.Filename = fileName
    do fs.CopyFromAndSave(gzip)

    do ##class(%File).Delete(tmpFile)
  }
  Quit $$$OK
}

ClassMethod CreateTempDir() As %String
{
  Set tDir = $$$FileTempDir

  /// In some cases, the $zu(140, 17) will return a negated error code. 
  /// For example, it can return -28, where 28 is Unix errno for "no space left on device".
  If tDir = ("-" _ -tDir) {
    Throw ##class(%Exception.General).%New("Failed to create temporary directory. Error code: " _ -tDir)
  }
  Return ##class(%File).NormalizeDirectory(tDir)
}

}
