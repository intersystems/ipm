Class IPM.Installer Extends %Projection.AbstractProjection
{

Projection Reference As Installer;

/// Version used for autoinstall release
Parameter VERSION;

/// Number of files for autoinstall release
Parameter FILESCOUNT = 0;

/// Application Definition
XData PM [ XMLNamespace = INSTALLER ]
{
<Manifest>
<Default Name="MODDIR" Dir="${MGRDIR}" />
<Default Name="SRCDIR" Dir="${MODDIR}src" />
<Default Name="REGISTRY" Value="https://pm.community.intersystems.com" />
<Default Name="TRACKINGID" Value="UA-126752118-1" />

<Namespace Name="${CURNS}" Code="${CURNSRoutineDB}" Data="${CURNSGlobalDB}" Create="no" Ensemble="0">
  <Configuration>
    <ClassMapping Package="%IPM" From="${CURNSRoutineDB}" />
    <RoutineMapping Routines="%IPM.*" Type="ALL" From="${CURNSRoutineDB}" />
  </Configuration>
  <Import File="${SRCDIR}" Recurse="1"/>
  <Invoke Class="%IPM.Main" Method="UpdateLanguageExtensions" CheckStatus="true" />
  <Invoke Class="IPM.Installer" Method="ZPMInit" CheckStatus="true">
    <Arg Value="${REGISTRY}"/>
    <Arg Value="${TRACKINGID}"/>
  </Invoke>
  <Invoke Class="IPM.Installer" Method="ZPMLoad" CheckStatus="true">
    <Arg Value="${MODDIR}"/>
  </Invoke>
</Namespace>

</Manifest>
}

XData MapOnly [ XMLNamespace = INSTALLER ]
{
<Manifest>
  <Namespace Name="${CURNS}" Code="${CURNSRoutineDB}" Data="${CURNSGlobalDB}" Create="no" Ensemble="0">
    <Configuration>
        <ClassMapping Package="%IPM" From="${CURNSRoutineDB}" />
        <RoutineMapping Routines="%IPM.*" Type="ALL" From="${CURNSRoutineDB}" />
    </Configuration>
  </Namespace>
</Manifest>
}

/// This is a method generator whose code is generated by XGL.
ClassMethod setup(
	ByRef pVars,
	pLogLevel As %Integer,
	pInstaller As %Installer.Installer,
	pLogger As %Installer.AbstractLogger) As %Status [ CodeMode = objectgenerator, Internal ]
{
  #;Let our XGL document generate code for this method.
  do %code.WriteLine(" If $Data(pVars, path)#10,path'="""" Set pVars(""MODDIR"")=path")
  do %code.WriteLine(" Set pVars(""CURNS"")=$namespace")
  do %code.WriteLine(" Set prevNS = $namespace")
  do %code.WriteLine(" New $Namespace")
  do %code.WriteLine(" Set $Namespace = ""%SYS"" ")
  do %code.WriteLine(" Kill properties")
  do %code.WriteLine(" Set sc = ##class(Config.Namespaces).Get(prevNS, .properties)")
  do %code.WriteLine(" Set pVars(""CURNSRoutineDB"")=$Get(properties(""Routines""))")
  do %code.WriteLine(" Set pVars(""CURNSGlobalDB"")=$Get(properties(""Globals""))")
  quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "PM")
}

/// This is a method generator whose code is generated by XGL.
ClassMethod Map(
	ByRef pVars,
	pLogLevel As %Integer,
	pInstaller As %Installer.Installer,
	pLogger As %Installer.AbstractLogger) As %Status [ CodeMode = objectgenerator, Internal ]
{
  #; Let our XGL document generate code for this method.
  do %code.WriteLine(" Set pVars(""CURNS"")=$namespace")
  #; Special case: if we're in %SYS and have an alternative mapping set up, keep it.
  do %code.WriteLine(" If ($Namespace = ""%SYS"") && (##class(%SYS.Namespace).GetPackageDest(""%SYS"",""%IPM"") '[ ""irislib"") { Quit $$$OK }")
  do %code.WriteLine(" Set prevNS = $namespace")
  do %code.WriteLine(" New $Namespace")
  do %code.WriteLine(" Set $Namespace = ""%SYS"" ")
  do %code.WriteLine(" Kill properties")
  do %code.WriteLine(" Set sc = ##class(Config.Namespaces).Get(prevNS, .properties)")
  do %code.WriteLine(" Set pVars(""CURNSRoutineDB"")=$Get(properties(""Routines""))")
  do %code.WriteLine(" Set pVars(""CURNSGlobalDB"")=$Get(properties(""Globals""))")
  do %code.WriteLine(" If ##class(Config.MapPackages).Exists(prevNS,""%IPM"") && ##class(Config.MapRoutines).Exists(prevNS,""%IPM.*"") { Quit $$$OK }")
  quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "MapOnly")
}

ClassMethod AsyncSetup(Args...)
{
  try {
    set tSC = ..setup(Args...)
  } catch ex {
    set tSC = ex.AsStatus()
  }
  do $system.Event.Signal($zparent, tSC)
}

ClassMethod ZPMInit(
	pRegistry As %String = "",
	pAnalyticsTrackingID As %String = "")
{
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetDefaultRegistry(pRegistry, 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetAnalyticsAvailable(1, 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetAnalyticsTrackingId(pAnalyticsTrackingID, 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue("ColorScheme","", 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue("PipCaller", "", 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue("UseStandalonePip", "", 0))
    $$$QuitOnError(##class(%IPM.Repo.UniversalSettings).SetValue("SemVerPostRelease", 0, 0))
    quit $$$OK
}

ClassMethod ZPMLoad(pDirectoryName)
{
  // Explicitly force DeveloperMode to 0 to avoid loading tests
  // Do not map here when installed from installer; that's handled via Installer XDatas if/when needed
  quit ##class(%IPM.Main).Shell("load "_pDirectoryName_" -DDeveloperMode=0 -DNoMapping=1")
}

ClassMethod MapIfLegacy()
{
  if ##class(%IPM.Utils.Migration).HasLegacyZPMPackage() {
    quit ##class(%IPM.Main).Shell("enable -globally -map")
  }
  quit $$$OK
}

ClassMethod InstallORASIfMissing()
{
  if ..ValidatePythonRuntime() {
    if '..ORASInstalled() {
      // Need to run in a background process to pick up new %IPM.Storage.Module definition
      write !,"Installing ORAS Python components..."
      job ..InitializeAndSignal()
      set result = $system.Event.WaitMsg("",30)
      set $listbuild(msg,sc) = result
      if (msg = 0) {
        write !,"ORAS installation timed out and may not have completed successfully."
      } elseif $$$ISERR(sc) {
        write !,"An error occurred installing Python dependencies: ",$system.Status.GetErrorText(sc)
      } else {
        write " done."
      }
    }
  } else {
    write !!,"WARNING: Flexible Python Runtime is not configured on this instance with a valid Python version (>=3.10). Not all IPM features will be available. If you wish to use ORAS registries, configure Flexible Python Runtime and then reinstall IPM.",!
  }
  quit $$$OK
}

ClassMethod InitializeAndSignal()
{
  set parent = $zparent
  set sc = ##class(%IPM.Main).Shell("zpm initialize -only")
  do $system.Event.Signal($zparent,sc)
}

ClassMethod ValidatePythonRuntime() As %Boolean
{
  try {
    set version = ..PythonMajorMinorVersion()
    if (+version < 3.10) {
      write !!,"WARNING: Python version "_version_" is not supported. IPM requires Python 3.10 or higher.",!
      return 0
    }
  } catch e {
    return 0
  }
  return 1
}

ClassMethod ORASInstalled() [ Language = python ]
{
  try:
    import oras
    return True
  except:
    return False
}

ClassMethod PythonMajorMinorVersion() [ Language = python ]
{
  import sys
  return f"{sys.version_info.major}.{sys.version_info.minor}"
}

ClassMethod EndCompile(qstruct) As %Status
{
  #; Behave as simple installer
  if (..#FILESCOUNT'>0)||(..#VERSION="") quit $$$OK

  #; This flag used in development
  if $data(^%IPM("skipinstall")) quit $$$OK

  #; Installed version newer
  if '..NeedInstall() quit $$$OK

  write !,"Extracting package"
  $$$QuitOnError(..ExtractPackage(.tModDir))

  write !,"Installing ZPM"

  set ts = $zhorolog
  set logFile=##class(%File).TempFilename()
  job ..AsyncSetup(tModDir, 3):(:::logFile):0
  if '$test {
    quit $$$ERROR($$$GeneralError, "Job did not start")
  }

  #; Wait setup
  set child=$zchild
  set tSC = $$$OK
  do {
    hang 1
    set $listbuild(res, tSC) = $system.Event.WaitMsg("", 10)
    quit:res=1
  } while $data(^$job(child))

  set fs=##class(%Stream.FileCharacter).%New()
  set fs.Filename=logFile
  while 'fs.AtEnd {
    write !,fs.ReadLine()
  }
  if ##class(%File).Delete(logFile)

  write !,"Time spent ",$zhorolog - ts

  quit tSC
}

/// Check currently installed version, if any
ClassMethod NeedInstall(Output version As %String)
{
  try {
    set module = ##class(%IPM.Storage.Module).NameOpen("zpm",0)
    if '$isobject(module) {
      return 1
    }

    set version = ##class(%IPM.General.SemanticVersion).FromString(..#VERSION)
    if $isobject(version) {
      return version.Follows(module.Version)
    }

  } catch ex {

  }
  quit 1
}

ClassMethod MakeFile(
	pPackagePath As %String,
	pInstaller As %String)
{
  set tPackage = ##class(%Stream.FileBinary).%New()
  set tInstaller = ##class(%Stream.FileCharacter).%New()
  if tPackage.LinkToFile(pPackagePath),tInstaller.LinkToFile(pInstaller) {
    $$$QuitOnError(..Make(tPackage, tInstaller))
    quit tInstaller.%Save()
  }
  quit $$$OK
}

ClassMethod Make(
	pPackage As %Stream.Object,
	ByRef pStream As %Stream.TmpCharacter) As %Status
{
  set sc = $$$OK
  try {
    set version = ""
	if ##class(%IPM.Storage.Module).NameExists("zpm",.id) {
        set version = ##class(%IPM.Storage.Module).VersionStringGetStored(id)
    }

    set tmpDir = ..CreateTempDir()
    $$$ThrowOnError(##class(%IPM.General.Archive).Extract(pPackage, tmpDir))

    do ..CollectPackage(tmpDir, .tList, tmpDir)

    do ..CompactPackage(.tList)

    set param = ##class(%Dictionary.ParameterDefinition).%OpenId($classname()_"||VERSION",0)
    set param.Default = version
    $$$ThrowOnError(param.%Save())

    set param = ##class(%Dictionary.ParameterDefinition).%OpenId($classname()_"||FILESCOUNT",0)
    set param.Default = $get(tList)
    $$$ThrowOnError(param.%Save())

    $$$ThrowOnError($system.OBJ.ExportToStream($classname()_".CLS", .pStream, "/diffexport/exportversion=iris2019.1"))
  } catch e {
    set sc = e.AsStatus()
  }
  quit sc
}

ClassMethod CollectPackage(
	pPath As %String,
	Output pList,
	pRoot As %String)
{
  set rs = ##class(%File).FileSetFunc(pPath)
  while rs.%Next() {
    if rs.Type="D" {
      do ..CollectPackage(rs.Name, .pList, pRoot)
    } else {
      #; Set $LISTBUILD(url) = $SYSTEM.CSP.FilenameToUrls(rs.Name)
      set pList($increment(pList)) = $listbuild(rs.Name, $extract(rs.Name, $length(pRoot) + 1, *))
    }
  }
}

ClassMethod CompactPackage(ByRef pList)
{
  set file = ""
  for i=1:1:$get(pList) {
    set $listbuild(file, name) = pList(i)
    write !,"Compact: ", file

    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = file

    set gzip = ##class(%Stream.FileBinaryGzip).%New()
    set gzip.Filename = tmpFile
    do gzip.CopyFromAndSave(stream)

    set gzip = ##class(%Stream.FileBinary).%New()
    set gzip.Filename = tmpFile

    set xdata = ##class(%Dictionary.XDataDefinition).%New()
    set xdata.Name = "Data"_i
    set xdata.Description = name
    set xdata.SequenceNumber = 100 + i
    do xdata.parentSetObjectId($classname())
    set chunkSize = 22800
    while 'gzip.AtEnd {
      set data = gzip.Read(chunkSize)
      set base64 = $system.Encryption.Base64Encode(data,1)
      do xdata.Data.Write(base64)
      set data1 = $system.Encryption.Base64Decode(base64)
    }
    do xdata.%Save()
    set hash = $system.Encryption.SHA1HashStream(gzip)

    do ##class(%File).Delete(tmpFile)
  }
}

ClassMethod ExtractPackage(Output pFolder As %String) As %String
{
  set pFolder = ..CreateTempDir()

  for i=1:1:..#FILESCOUNT {
    set xdata = ##class(%Dictionary.XDataDefinition).%OpenId($classname()_"||Data"_i,0)
    set name = xdata.Description
    set fileName = pFolder_name

    set tParentFolder = ##class(%File).ParentDirectoryName(fileName)
    if '##class(%File).DirectoryExists(tParentFolder) {
      do ##class(%File).CreateDirectoryChain(tParentFolder)
    }

    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = tmpFile
    set prev = ""
    set chunkSize = 30400
    do {
      set data = prev
      if 'xdata.Data.AtEnd {
        set data = data _ xdata.Data.Read()
      }
      set data = $zstrip(data, "*C")
      set prev = $extract(data, chunkSize + 1, *)
      set data = $extract(data, 1, chunkSize)
      set chunk = $system.Encryption.Base64Decode(data)
      do stream.Write(chunk)
    } while (prev'="")||('xdata.Data.AtEnd)
    do stream.%Save()

    set gzip = ##class(%Stream.FileBinaryGzip).%New()
    set gzip.Filename = tmpFile

    if $piece(fileName,".",*) = "whl" {
      // TODO: generalize to other binary file types?
      set fs = ##class(%Stream.FileBinary).%New()
    } else {
      set fs = ##class(%Stream.FileCharacter).%New()
    }
    set fs.Filename = fileName
    do fs.CopyFromAndSave(gzip)

    do ##class(%File).Delete(tmpFile)
  }
  quit $$$OK
}

ClassMethod CreateTempDir() As %String
{
  set tDir = $$$FileTempDir

  /// In some cases, the $zu(140, 17) will return a negated error code.
  /// For example, it can return -28, where 28 is Unix errno for "no space left on device".
  if tDir = ("-" _ -tDir) {
    throw ##class(%Exception.General).%New("Failed to create temporary directory. Error code: " _ -tDir)
  }
  return ##class(%File).NormalizeDirectory(tDir)
}

}
